// HarunoUnpacker.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include <cstdio>
#include <string>
#include <vector>
#include <Windows.h>

struct PackageEntry
{
	/// Offset from the beginning.
	unsigned offset_;
	/// File size.
	unsigned size_;
	/// File checksum.
	unsigned checksum_;
};

struct Header
{
	char     sign_[4];
	unsigned count_;
	unsigned offset_;
};

struct FileBuf
{
	std::wstring name_;
	/// Offset from the beginning.
	unsigned offset_;
	/// File size.
	unsigned size_;
	/// File checksum.
	unsigned checksum_;
};


#pragma pack (1)
union FileNameKeyInfo
{
	unsigned char c_key[8];
	WORD          w_key[4];
	DWORD         d_key[2];
};
#pragma pack ()

int DecodeFileName(wchar_t* in_file, size_t len)
{
	FileNameKeyInfo Info;
	memcpy(Info.c_key, "kdus*30.d(@~xpag", 16);
	Info.d_key[0] ^= 0x36F51A97;
	Info.d_key[1] ^= 0x65DE7A20;

	Info.w_key[0] ^= 0xFCFC;
	Info.w_key[1] ^= 0x561F;
	Info.w_key[2] ^= 0xCA1A;
	Info.w_key[3] ^= 0x61F7;

	int i;
	for (i = 0; i < len; i++)
	{
		in_file[i] ^= Info.w_key[i % 4];
	}
	return i;
}

union RecordInfo
{
	DWORD size;
	char  c_key[4];
};


DWORD EncodeSize(DWORD in)
{
	RecordInfo info;
	memcpy(info.c_key, "ST,.", 4);

	for (int i = 0; i < 3; i++)
	{
		info.c_key[i] ^= 0x69;
	}
	return in ^ info.size;
}

DWORD EncodeOffset(DWORD in)
{
	RecordInfo info;
	memcpy(info.c_key, "ZXDF", 4);

	for (int i = 0; i < 3; i++)
	{
		info.c_key[i] ^= 0x5F;
	}
	return in ^ info.size;
}

DWORD EncodeHeaderSize(DWORD in)
{
	RecordInfo info;
	memcpy(info.c_key, "-2dM", 4);

	for (int i = 0; i < 3; i++)
	{
		info.c_key[i] ^= 0x7B;
	}
	return in ^ info.size;
}


DWORD EncodeHeaderOffset(DWORD in)
{
	RecordInfo info;
	memcpy(info.c_key, "+=dw", 4);

	for (int i = 0; i < 3; i++)
	{
		info.c_key[i] ^= 0x4D;
	}
	return in ^ info.size;
}

std::vector<FileBuf> FileList;


void DecodeFile2(byte* debuf, size_t desize)
{
	size_t key_idx = 0;
	size_t xor_idx = 0;

	static byte key[] =
	{
		0xFE, 0xF8, 0xE7, 0xB0, 0xE5, 0xE5, 0x28, 0x4F, 0xB5, 0x2F, 0x48, 0xFE, 0xE5, 0xE9, 0x4B, 0xDE,
		0xB7, 0x4F, 0x72, 0x95, 0x8B, 0xE0, 0x03, 0x80, 0xE7, 0xCF, 0x0F, 0x7B, 0x92, 0x05, 0xEB, 0xF8,
		0xE2, 0x88, 0xCE, 0x73, 0x04, 0x38, 0xD2, 0x7D, 0x8C, 0xD2, 0x88, 0x77, 0xE7, 0x92, 0x75, 0x8F,
		0x4E, 0xB7, 0x8D, 0x05, 0x79, 0x88, 0x83, 0x0E, 0xF9, 0xE9, 0x2C, 0xDB, 0x77, 0xDB, 0x95, 0x54,
		0xD5, 0x9E, 0x4E, 0x79, 0x57, 0x23, 0x08, 0x97, 0x0E, 0x5D, 0x55, 0xF9, 0xE5, 0xE0, 0x7F, 0x58,
		0x57, 0xC8, 0xE9, 0x47, 0xDE, 0x22, 0xFF, 0xFD, 0x87, 0x52, 0x42, 0xFB, 0xE9, 0xB8, 0x77, 0x7C,
		0x95, 0x77, 0x74, 0xF9, 0xD5, 0x5E, 0xE4, 0x50, 0x74, 0x7F, 0xF2, 0x0B, 0xDE, 0x40, 0xE7, 0x47,
		0xF5, 0x03, 0xCC, 0x2E, 0xED, 0x7F, 0x34, 0x25, 0xE0, 0x74, 0x27, 0x98, 0x7C, 0xED, 0x79, 0xF4,
		0xB5, 0x23, 0x08, 0x7E, 0x7D, 0x92, 0xF7, 0xEB, 0x93, 0xF0, 0x7E, 0x89, 0x5E, 0xF9, 0xF8, 0x7E,
		0xEF, 0xE8, 0xE9, 0x48, 0xC2, 0xEC, 0x55, 0x7B, 0x2B, 0x33, 0xE7, 0x40, 0x0D, 0xDC, 0x7D, 0xE7,
		0x5B, 0xCF, 0xC8, 0x35, 0xD5, 0x77, 0x52, 0x8D, 0x82, 0xEC, 0x45, 0xB8, 0x73, 0xE5, 0x4F, 0x27,
		0x7C, 0x0F, 0x39, 0xDE, 0x5B, 0x37, 0x4E, 0xDE, 0xE4, 0x49, 0x0B, 0x7C, 0x57, 0xE3, 0x43, 0xEE,
		0x77, 0x07, 0x74, 0x73, 0xC0, 0x43, 0xE3, 0x58, 0x5E, 0x0F, 0x9F, 0x02, 0x4C, 0x7E, 0x8B, 0x05,
		0x9F, 0x2D, 0xEE, 0x72, 0x54, 0x53, 0xFF, 0x97, 0xEE, 0x0B, 0x34, 0x58, 0xCF, 0xE3, 0x00, 0x78,
		0xBE, 0xE3, 0xF5, 0x75, 0xE4, 0x87, 0x7C, 0xFC, 0x80, 0xEF, 0xC4, 0x8D, 0x47, 0x3E, 0x5D, 0xD0,
		0x37, 0xBC, 0xE5, 0x70, 0x77, 0x78, 0x08, 0x4F, 0xBB, 0xEB, 0xE2, 0x78, 0x07, 0xE8, 0x73, 0xBF,
		0xD8, 0x29, 0xB9, 0x57, 0x3D, 0x5E, 0x77, 0xD0, 0x87, 0x9B, 0x2D, 0x0C, 0x7B, 0xD5, 0xE9, 0x59,
		0x22, 0x9F, 0x95, 0x73, 0x7E, 0x35, 0xB5, 0x7E, 0xD5, 0xB5, 0xE7, 0xE7, 0xD5, 0xF5, 0x07, 0xD7,
		0xBE, 0xBF, 0xF3, 0x45, 0x3F, 0xF5, 0x75, 0xDD, 0x4C, 0x77, 0x7E, 0x7F, 0x74, 0xEC, 0x7E, 0x7F,
		0x27, 0x74, 0x0E, 0xDB, 0x27, 0x4C, 0xE5, 0xF5, 0x0E, 0x2D, 0x70, 0xC4, 0x40, 0x5D, 0x4F, 0xDE
	};
	for (xor_idx = 0; xor_idx < desize; xor_idx++, key_idx++, key_idx = key_idx & 0x800000FF)
	{
		debuf[xor_idx] ^= key[key_idx];
	}

}

int main(int argc, char* argv[])
{
	if (argc < 2)
	{
		wprintf(L"Usage : Unpackager <file>\n");
		return -1;
	}
	FILE* file = fopen(argv[1], "rb");
	printf(std::string("Open " + std::string(argv[1]) + "to dump file.\n").c_str());
	if (!file)
	{
		printf(std::string("Couldn't open " + std::string(argv[1]) + " to dump file.\n").c_str());
		return -1;
	}

	char tSign[4];
	fread(tSign, 1, 4, file);
	if (memcmp(tSign, "XMOE", 4))
	{
		printf("Invaild package!\n");
		fclose(file);
		return -1;
	}
	fseek(file, 4, SEEK_SET);
	DWORD countOffile = 0;
	fread(&countOffile, 1, 4, file);
	//countOffile = EncodeHeaderSize(countOffile);
	printf("count %d\n", countOffile);

	DWORD DataOffset = 0;
	fseek(file, 8, SEEK_SET);
	fread(&DataOffset, 1, 4, file);
	//DataOffset = EncodeHeaderOffset(DataOffset);
	printf("Offset %08x\n", DataOffset);

	char *FileBuffer = new char[DataOffset - sizeof(Header)];
	fseek(file, sizeof(Header), SEEK_SET);
	fread(FileBuffer, 1, DataOffset - sizeof(Header), file);
	DecodeFile2((byte*)FileBuffer, DataOffset - sizeof(Header));

	FILE* index = fopen("index.data", "wb");
	fwrite(FileBuffer, 1, DataOffset - sizeof(Header), index);
	fclose(index);

	DWORD iPos = 0;
	for (DWORD i = 0; i < countOffile; ++i)
	{
		wchar_t* name = (wchar_t*)(FileBuffer + iPos);
		wprintf(L"Dumping %s\n", name);
		iPos += (wcslen(name) + 1) * 2;
		FileBuf buf;
		buf.name_ = name;
		PackageEntry *entry = (PackageEntry*)(FileBuffer + iPos);
		buf.checksum_ = entry->checksum_;

		buf.offset_ = entry->offset_;
		buf.size_ = entry->size_;

		FileList.push_back(buf);
		iPos += sizeof(PackageEntry);
	}

	delete[] FileBuffer;
	for (DWORD i = 0; i < countOffile; ++i)
	{
		fseek(file, FileList[i].offset_, SEEK_SET);
		char* mFile = new char[FileList[i].size_];
		fread(mFile, 1, FileList[i].size_, file);
		FILE* output = NULL;
		output = _wfopen(FileList[i].name_.c_str(), L"wb");
		wprintf(L"Writing file : %s\n", FileList[i].name_.c_str());
		if (output == NULL)
		{
			wprintf(L"Couldn't write file : %s\n", FileList[i].name_.c_str());
			delete[] mFile;
			continue;
		}
		fwrite(mFile, 1, FileList[i].size_, output);
		delete[] mFile;
		fclose(output);
	}
	fclose(file);
	return 0;
}
